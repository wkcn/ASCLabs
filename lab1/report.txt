实验一多进程实验

进程创建的例1

屏幕输出两行，依次是1和0
解释：调用fork()函数时，系统创建新进程并为其分配资源，然后将原进程的所有值都复制到新进程中，只有少数值和原来进程的值不同。
父进程的fork()返回的是子进程的id值
子进程中的fork()返回的是0;

参考资料：http://blog.csdn.net/jason314/article/details/5640969

进程创建的例2

屏幕输出了：
**1**
**3**
**1**
**2**
**2**

分析：
1 void main(){
2   int pid1=fork();
3   printf(“**1**\n”);
4   if(pid1==0){int pid2=fork();printf(“**2**\n”);}
5   else printf(“**3**\n”);
6 }

记父进程为A
第2行的fork()创建了一个子进程b

对于进程A, fork()返回的值非0,
在第3行输出**1**
经过第4行条件判断，转到else分支，输出**3**

对于进程b, fork()返回的值为0
到第3行，输出**1**
第4行，条件判断后转到yes分支，
执行int pid2 = fork();
创建一个子进程c

进程b输出**2**
进程c输出**2**

进程创建的例3
输出了XXXXO
4个X, 1个0
分析：
1  int i, a=0;  
2  pid_t pid;
3  if((pid=fork()))a=1;
4  for(i=0; i<2; i++){  
5      printf("X");  
6  }  
7  if(pid==0)printf("%d\n",a);

记父进程为A,
当执行到第3行时，创建一个子进程b

父进程A中，pid=id of process b，不为0
因此a = 1
进入第4行循环，输出2个X
第7行中不满足条件

子进程b中，pid=0, 不满足第3行的条件，a仍为0
在第4行的循环中输出2个X
在第7行满足条件，输出0\n
